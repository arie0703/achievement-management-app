# name: CI/CD Pipeline

# on:
#   push:
#     branches: [ main, develop ]
#     tags: [ 'v*' ]
#   pull_request:
#     branches: [ main, develop ]

# env:
#   GO_VERSION: '1.24'
#   REGISTRY: ghcr.io
#   IMAGE_NAME: ${{ github.repository }}

# jobs:
#   test:
#     name: Test
#     runs-on: ubuntu-latest
    
#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4
      
#     - name: Set up Go
#       uses: actions/setup-go@v4
#       with:
#         go-version: ${{ env.GO_VERSION }}
        
#     - name: Cache Go modules
#       uses: actions/cache@v3
#       with:
#         path: |
#           ~/.cache/go-build
#           ~/go/pkg/mod
#         key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
#         restore-keys: |
#           ${{ runner.os }}-go-
          
#     - name: Download dependencies
#       run: go mod download
      
#     - name: Run tests
#       run: go test -v -race -coverprofile=coverage.out ./...
      
#     - name: Upload coverage to Codecov
#       uses: codecov/codecov-action@v3
#       with:
#         file: ./coverage.out
#         flags: unittests
#         name: codecov-umbrella
        
#   lint:
#     name: Lint
#     runs-on: ubuntu-latest
    
#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4
      
#     - name: Set up Go
#       uses: actions/setup-go@v4
#       with:
#         go-version: ${{ env.GO_VERSION }}
        
#     - name: Run golangci-lint
#       uses: golangci/golangci-lint-action@v3
#       with:
#         version: latest
        
#   build:
#     name: Build
#     runs-on: ubuntu-latest
#     needs: [test, lint]
    
#     strategy:
#       matrix:
#         goos: [linux, darwin, windows]
#         goarch: [amd64, arm64]
#         exclude:
#           - goos: windows
#             goarch: arm64
            
#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4
#       with:
#         fetch-depth: 0
        
#     - name: Set up Go
#       uses: actions/setup-go@v4
#       with:
#         go-version: ${{ env.GO_VERSION }}
        
#     - name: Cache Go modules
#       uses: actions/cache@v3
#       with:
#         path: |
#           ~/.cache/go-build
#           ~/go/pkg/mod
#         key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
#         restore-keys: |
#           ${{ runner.os }}-go-
          
#     - name: Get version
#       id: version
#       run: |
#         if [[ $GITHUB_REF == refs/tags/* ]]; then
#           VERSION=${GITHUB_REF#refs/tags/}
#         else
#           VERSION=$(git describe --tags --always --dirty)
#         fi
#         echo "version=$VERSION" >> $GITHUB_OUTPUT
#         echo "build_time=$(date -u '+%Y-%m-%d_%H:%M:%S')" >> $GITHUB_OUTPUT
#         echo "commit_hash=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
        
#     - name: Build binaries
#       env:
#         GOOS: ${{ matrix.goos }}
#         GOARCH: ${{ matrix.goarch }}
#         VERSION: ${{ steps.version.outputs.version }}
#         BUILD_TIME: ${{ steps.version.outputs.build_time }}
#         COMMIT_HASH: ${{ steps.version.outputs.commit_hash }}
#       run: |
#         mkdir -p build/${{ matrix.goos }}-${{ matrix.goarch }}
        
#         LDFLAGS="-ldflags \"-X main.Version=$VERSION -X main.BuildTime=$BUILD_TIME -X main.CommitHash=$COMMIT_HASH\""
        
#         if [ "${{ matrix.goos }}" = "windows" ]; then
#           go build $LDFLAGS -o build/${{ matrix.goos }}-${{ matrix.goarch }}/achievement-api.exe ./cmd/api
#           go build $LDFLAGS -o build/${{ matrix.goos }}-${{ matrix.goarch }}/achievement-app.exe ./cmd/cli
#         else
#           go build $LDFLAGS -o build/${{ matrix.goos }}-${{ matrix.goarch }}/achievement-api ./cmd/api
#           go build $LDFLAGS -o build/${{ matrix.goos }}-${{ matrix.goarch }}/achievement-app ./cmd/cli
#         fi
        
#     - name: Upload build artifacts
#       uses: actions/upload-artifact@v3
#       with:
#         name: binaries-${{ matrix.goos }}-${{ matrix.goarch }}
#         path: build/${{ matrix.goos }}-${{ matrix.goarch }}/
        
#   docker:
#     name: Docker Build and Push
#     runs-on: ubuntu-latest
#     needs: [test, lint]
#     if: github.event_name != 'pull_request'
    
#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4
      
#     - name: Set up Docker Buildx
#       uses: docker/setup-buildx-action@v3
      
#     - name: Log in to Container Registry
#       uses: docker/login-action@v3
#       with:
#         registry: ${{ env.REGISTRY }}
#         username: ${{ github.actor }}
#         password: ${{ secrets.GITHUB_TOKEN }}
        
#     - name: Extract metadata
#       id: meta
#       uses: docker/metadata-action@v5
#       with:
#         images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
#         tags: |
#           type=ref,event=branch
#           type=ref,event=pr
#           type=semver,pattern={{version}}
#           type=semver,pattern={{major}}.{{minor}}
#           type=semver,pattern={{major}}
#           type=sha
          
#     - name: Build and push Docker image
#       uses: docker/build-push-action@v5
#       with:
#         context: .
#         platforms: linux/amd64,linux/arm64
#         push: true
#         tags: ${{ steps.meta.outputs.tags }}
#         labels: ${{ steps.meta.outputs.labels }}
#         cache-from: type=gha
#         cache-to: type=gha,mode=max
        
#   release:
#     name: Create Release
#     runs-on: ubuntu-latest
#     needs: [build, docker]
#     if: startsWith(github.ref, 'refs/tags/')
    
#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4
#       with:
#         fetch-depth: 0
        
#     - name: Download all artifacts
#       uses: actions/download-artifact@v3
#       with:
#         path: artifacts/
        
#     - name: Create distribution packages
#       run: |
#         mkdir -p dist
        
#         # Create packages for each platform
#         for dir in artifacts/binaries-*; do
#           platform=$(basename "$dir" | sed 's/binaries-//')
          
#           if [[ $platform == *"windows"* ]]; then
#             cd "$dir"
#             zip -r "../../dist/achievement-app-${{ github.ref_name }}-${platform}.zip" ./* ../../config/* ../../README.md ../../.env.example
#             cd - > /dev/null
#           else
#             tar -czf "dist/achievement-app-${{ github.ref_name }}-${platform}.tar.gz" \
#               -C "$dir" . \
#               -C "../../config" . \
#               -C ".." README.md .env.example
#           fi
#         done
        
#         # Generate checksums
#         cd dist
#         sha256sum * > checksums.txt
#         cd - > /dev/null
        
#     - name: Generate release notes
#       id: release_notes
#       run: |
#         if [ -f CHANGELOG.md ]; then
#           # Extract changelog for this version
#           awk '/^## \[/{if(p) exit; if(/\[${{ github.ref_name }}\]/) p=1; next} p' CHANGELOG.md > release_notes.txt
#         else
#           echo "Release ${{ github.ref_name }}" > release_notes.txt
#           echo "" >> release_notes.txt
#           echo "## Changes" >> release_notes.txt
#           git log --pretty=format:"- %s" $(git describe --tags --abbrev=0 HEAD^)..HEAD >> release_notes.txt
#         fi
        
#     - name: Create GitHub Release
#       uses: softprops/action-gh-release@v1
#       with:
#         files: dist/*
#         body_path: release_notes.txt
#         draft: false
#         prerelease: ${{ contains(github.ref_name, '-') }}
#       env:
#         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
